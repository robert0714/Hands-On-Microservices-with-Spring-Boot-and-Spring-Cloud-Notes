# Automating the provision of certificates
<!-- MarkdownTOC -->
- [Automating the provision of certificates](#automating-the-provision-of-certificates)
    - [Deploying the Cert Manager and defining Let's Encrypt issuers](#deploying-the-cert-manager-and-defining-lets-encrypt-issuers)
    - [Creating an HTTP tunnel using ngrok](#creating-an-http-tunnel-using-ngrok)
    - [Provisioning certificates with the Cert Manager and Let's Encrypt](#provisioning-certificates-with-the-cert-manager-and-lets-encrypt)
       - [Using Let's Encrypt's staging environment](#using-lets-encrypts-staging-environment)
       - [Using Let's Encrypt's production environment](#using-lets-encrypts-production-environment)
    - [Cleaning up](#cleaning-up)
<!-- /MarkdownTOC -->
As mentioned in the introduction to this chapter, we will use the Cert Manager to automate the provision of certificates used by the external HTTPS endpoint exposed by the ingress. The Cert Manager will run as an add-on in Kubernetes and will be configured to request the issuing of certificates from Let's Encrypt with a free Certificate Authority that can be used to automate the issuing of certificates. 

To be able to verify that we own the DNS name that the certificate shall be issued for, Let's Encrypt requires access to the endpoint we want to issue the certificate for. Since our Kubernetes cluster runs locally in Minikube, we must make it possible for Let's Encrypt to access our cluster during the provisioning. 

We will use the ngrok tool to create a temporary HTTP tunnel from the internet to our local Kubernetes cluster to be used by Let's Encrypt.

For more information on each product, see the following:

- Cert Manager: http://docs.cert-manager.io/en/latest/index.html
- Let's Encrypt: https://letsencrypt.org/docs/
- ngrok: https://ngrok.com/docs
 
All this together might seem a bit overwhelming, so let's take it step by step:

1. Deploy the Cert Manager and define issuers in Kubernetes based on Let's Encrypt.
2. Create an HTTP tunnel using ngrok.
3. Provision certificates with the Cert Manager and Let's Encrypt.
4. Verify that we got certificates from Let's Encrypt.
5. Clean up.

- The HTTP tunnel is only required if your Kubernetes cluster isn't reachable on the internet. If its ingress resource can be accessed directly from the internet, the use of ngrok can be skipped.
## Deploying the Cert Manager and defining Let's Encrypt issuers
To deploy the Cert Manager, we can execute a single Kubernetes definition file that will create a namespace, cert-manager, and then deploy the Cert Manager into the namespace. We will install version 1.3.0, the latest available version when writing this chapter. Run the following command:

```
kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.3.0/cert-manager.yaml
```

If you get an error message such as ***unable to recognize "https://github.com/jetstack/cert-manager/releases/download/v1.3.0/cert-manager.yaml": no matches for kind "Issuer" in version "certmanager.k8s.io/v1alpha1***", then simply rerun the command again.

Wait for the deployment and its pods to be available:
```
kubectl wait --timeout=600s --for=condition=ready pod --all -n cert-manager
```
Expect output similar to the following from the command:
```
$ kubectl wait --timeout=600s --for=condition=ready pod --all -n cert-manager
pod/cert-manager-76b7c557d5-lqgvt condition met
pod/cert-manager-cainjector-655d695d74-hg5ww condition met
pod/cert-manager-webhook-78bd968fbf-8rjnl condition met
```
With the Cert Manager in place, we can define issuers in Kubernetes that are based on Let's Encrypt.

Let's Encrypt exposes the following issuers:

- ***Staging environment***, to be used during development and test phases where it
    can be expected that a lot of short-lived certificates are requested. The staging
    environment allows for the creation of many certificates but the root ***CA*** (short
    for ***Certificate Authority***) in the certificate is not trusted. This means that
    certificates from the staging environment can't be used to protect web pages or
    APIs used by a web browser. A web browser won't trust its root CA and will
    complain when a user opens a web page protected by certificates from the
    staging environment.
- ***Production environment***, it uses a trusted root CA to issue certificates. It can,
    therefore, be used to issue certificates that are trusted by web browsers. The
    production environment limits the number of certificates that can be issued. For
    example, only 50 new certificates per week can be issued per registered domain,
    for instance, in case ***ngrok.io***.


We will register two issuers in Kubernetes, one for the staging environment and one for the
production environment. Issuers can be registered either globally in the cluster or locally in
a namespace. To keep things together, we will use namespace local issuers.

Communication between the Cert Manager and Let's Encrypt during the provision of
certificates is based on a standard protocol, ***Automated Certificate Management***
***Environment v2***, or ***ACME v2*** for short. Let's Encrypt will act as a CA and the Cert
Manager will act as an ACME client. To validate the ownership of a DNS name, the ACME
protocol specifies two types of challenge that a CA can use:
- ***http-01***: The CA asks the ACME client for a randomly named file to be made
    available under the following
    URL: ***http://<domainname>/.well-known/acme-challenge/<randomfilename>***. If the CA succeeds in accessing the file using this URL, the ownership of the domain is validated.
- ***dns-01***: The CA asks the ACME client for a specified value to be placed in a TXT record, ***_acme-challenge.<YOUR_DOMAIN>***, under the domain in the DNS server. This is typically achieved by using an API of the DNS provider. If the CA succeeds in accessing the specified content in the TXT record in the DNS server,the ownership of the domain is validated.
    
Automating a ***dns-01*** based challenge is harder to achieve than automating an
***http-01*** challenge in most cases; however, it is preferred, for example, if the HTTP
endpoint isn't available on the internet. A ***dns-01*** challenge also supports issuing wildcard
certificates, which an ***http-01*** challenge can't be used for. In this chapter, we will configure
the Cert Manager to use an ***http-01***â€”based challenge.

The definition of the issuer for the Let's Encrypt staging environment looks like the following:

Chapter17\kubernetes\services\base\letsencrypt-issuer-staging.yaml
```Chapter17\kubernetes\services\base\letsencrypt-issuer-staging.yaml
apiVersion: certmanager.k8s.io/v1alpha1
kind: Issuer
metadata:
  name: letsencrypt-issuer-staging
spec:
  acme:
    email: <your email address>
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: letsencrypt-issuer-staging-account-key
    solvers:
    - http01:
        ingress:
          class: nginx
```
migration info:
https://github.com/jetstack/cert-manager/releases/tag/v0.11.0

The following explains the preceding source code:
- The ***name*** of the issuer, ***letsencrypt-issuer-staging***, will be used in the
    ingress when referring to the issuer to be used when provisioning certificates for
    the ingress.
- The ***email*** must be filled in with your email address. Let's Encrypt will use the
    email address to contact you about expiring certificates and issues, if any, related
    to your account.
- The ***server*** field points out the URL for the Let's Encrypt staging environment.
- The ***privateKeySecretRef*** field contains the name of a secret. This secret will
    be created by the Cert Manager and will contain an ACME/Let's Encrypt
    ***account private key***. This key identifies you (or your company) as a user of
    the ACME service, that is, Let's Encrypt. It is used to sign requests sent to Let's
    Encrypt to validate your identity.
- The ***solver*** definition declares that an ***http-01*** challenge shall be used to verify
    the ownership of the domain name.

The definition of the issuer for the Let's Encrypt production environment looks the same,
the major difference is the ACME server URL used: ***https://acme-v02.api.letsencrypt.org/directory***.

Edit the following files and replace ***<your email address>*** with your email address:
    
- kubernetes/services/base/letsencrypt-issuer-staging.yaml
- kubernetes/services/base/letsencrypt-issuer-prod.yaml

Apply the definitions with the following commands:
```bash
kubectl apply -f kubernetes/services/base/letsencrypt-issuer-staging.yaml
kubectl apply -f kubernetes/services/base/letsencrypt-issuer-prod.yaml
```
We now have the Cert Manager in place and have registered issuers for the Let's Encrypt staging and production environment. The next step is to create an HTTP tunnel using ***ngrok***.

## Creating an HTTP tunnel using ngrok
The free subscription to ngrok can be used to create an HTTP tunnel where ngrok
terminates the HTTPS traffic using its own wildcard certificate for *.ngrok.io, that is,
before the HTTP requests reach the ingress resource in Kubernetes. The client that sends the
HTTPS request will only see the ngrok certificate and not the certificate exposed by the
ingress resource in Kubernetes. This means that we can't use the HTTP tunnel to test a
certificate that has been issued by Let's Encrypt and is used by the ingress resource in
Kubernetes.

But the HTTP tunnel can be used during the provisioning phase where Let's Encrypt needs
to verify that the ACME client owns the DNS name it is requested to issue a certificate for.
The DNS name will be the hostname that ngrok assigns to the HTTP tunnel, for
example, 6cc09528.ngrok.io. Once the provisioning is performed, we can shut down the
HTTP tunnel and redirect the hostname to the IP address of the Minikube instance (using
the local /etc/hosts file). 

- For paying customers, ngrok provides a TLS tunnel that passes through
HTTPS traffic instead of terminating it; that is, a client that sends an
HTTPS request will be able to see and verify the certificate exposed by the
ingress resource in Kubernetes. Using a TLS tunnel instead of the HTTP
tunnel should make this extra step unnecessary.

Perform the following steps to create the HTTP tunnel:
1. Create the HTTP tunnel with the following command:
```
ngrok http https://minikube.me:443
```
2. Expect output similar to the following screenshot:
```
```
3. Pick up the hostname for the HTTP tunnel, 6cc09528.ngrok.io in the
preceding example, and save it in an environment variable such as the following:
```
NGROK_HOST=6cc09528.ngrok.io
```
With the HTTP tunnel in place, we can prepare the definition of the ingress resource for
automatic provisioning of its certificate using the Cert Manager and Let's Encrypt!

## Provisioning certificates with the Cert Manager and Let's Encrypt
### Using Let's Encrypt's staging environment
### Using Let's Encrypt's production environment
## Cleaning up
