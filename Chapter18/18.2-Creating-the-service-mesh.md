# Creating the service mesh
## Source code changes 
### Update the deployment scripts to inject Istio proxies
### Changing the file structure of the Kubernetes definition files
### Adding Kubernetes definition files for Istio 
## Running commands to create the service mesh

Create the service mesh by running the following commands:
1. Build Docker images from source with the following commands:
```
          cd $BOOK_HOME/Chapter18
          eval $(minikube docker-env)
          ./gradlew build && docker-compose build
```
2. Recreate the hands-on namespace, and set it as the default namespace:
```
   kubectl delete namespace hands-on
   kubectl create namespace hands-on
   kubectl config set-context $(kubectl config current-context) --namespace=hands-on
```
3. Execute the deployment by running the ***deploy-dev-env.bash*** script with the following command:
```
   ./kubernetes/scripts/deploy-dev-env.bash
```
4. Once the deployment is complete, verify that we have two containers in each of the microservice pods:
```
   kubectl get pods
```  
  Using a Service Mesh to Improve Observability and Management Chapter 18
  Note that the pods that run our microservices report two containers per pod; that is, they have the Istio proxy injected as a sidecar!
5. Run the usual tests with the following command:
```
   ./test-em-all.bash
```
           The default values for script test-em-all.bash have been updated from previous chapters to accommodate Kubernetes running in Minikube.           
  Expect the output to be similar to what we have seen in previous chapters:
6. You can try out the APIs manually by running the following commands:
```
  ACCESS_TOKEN=$(curl -k https://writer:secret@minikube.me/oauth/token -d grant_type=password -d username=magnus -d password=password -s | jq            .access_token -r)
  
  curl -ks https://minikube.me/product-composite/2 -H "Authorization:Bearer $ACCESS_TOKEN" | jq .productId
```
Expect the requested product ID, 2, in the response.

With the service mesh up and running, let's see how we can observe what's going on in the service mesh using Kiali!
